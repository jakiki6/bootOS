     1                                  ;;;; phosphene
     2                                  ;;;;
     3                                  ;;;; fractal video feedback in the MBR
     4                                  ;;;;
     5                                  ;;;;   by:      keegan
     6                                  ;;;;   greets:  dei, mrule
     7                                  ;;;;
     8                                  ;;;; TO RUN:
     9                                  ;;;;   nasm -f bin -o phosphene.mbr phosphene.asm
    10                                  ;;;;   qemu -hda phosphene.mbr  # or boot it for real
    11                                  
    12                                  
    13                                  ;;;; CONSTANTS
    14                                  
    15                                  ; MBR code runs in 16-bit mode at address 0x7C00
    16                                  bits 16
    17                                  org  0x7C00
    18                                  
    19                                  ; start of scratch ram
    20                                  ram_start     equ 0x7E00
    21                                  
    22                                  ; address relative to ram_start where we
    23                                  ; store rendered text
    24                                  rendered_text equ 0x2000
    25                                  
    26                                  ; address of first element of stack, in ss
    27                                  stack_start   equ 0x1000
    28                                  
    29                                  ; start of video RAM
    30                                  vram_start    equ 0xA0000
    31                                  
    32                                  ; VGA palette registers
    33                                  vga_dac_addr  equ 0x3C8
    34                                  
    35                                  ; VESA mode 101h: 640 x 480 x byte
    36                                  vesa_mode     equ 0x101
    37                                  
    38                                  ; Feedback buffers:
    39                                  ;   width : 512 pixels
    40                                  ;   height: 3 segments of 128 pixels each
    41                                  ;
    42                                  ; The three segments:
    43                                  ;   buffer A:  10000 20000 30000
    44                                  ;   buffer B:  40000 50000 60000
    45                                  ;
    46                                  ; Use bit ops to find these from fs = 1000 or 4000
    47                                  width  equ 512
    48                                  height equ 384
    49                                  
    50                                  ; viewport size = 2 log_2 e
    51                                  ; scale by the reciprocal
    52                                  height_scale equ height * 1000 / 2886
    53                                  width_scale  equ width  * 1000 / 2886
    54                                  
    55                                  ; text rendered in mode 13h
    56                                  text_width  equ  64
    57                                  text_height equ  16
    58                                  text_num    equ   2
    59                                  text_y      equ  60
    60                                  text_x      equ 192
    61                                  
    62                                  ; Color palette:
    63                                  ;   Each channel is incremented at a different rate
    64                                  ;   For stupid reasons, inc_red is rounded to a multiple of 4
    65                                  inc_red          equ  4    ; u8   red increment per palette entry
    66                                  inc_green        equ  5    ; u8   green "
    67                                  inc_blue         equ  6    ; u8   blue  "
    68                                  
    69                                  
    70                                  ;;;; GLOBAL VARIABLES
    71                                  ; ds, ss  = scratch RAM
    72                                  ; fs      = initial read segment per frame
    73                                  ;
    74                                  ; bp      = frame counter
    75                                  ; si      = 0
    76                                  
    77                                  
    78                                  ;;;; ENTRY POINT
    79                                      ; set up segments
    80 00000000 B03F                        mov al, "?"
    81 00000002 CD26                        int 0x26
    82 00000004 BF[D101]                    mov di, text
    83 00000007 89F1                        mov cx, si
    84 00000009 81E98077                    sub cx, 0x7780
    85 0000000D F3A4                        rep movsb
    86 0000000F C64501AA                    mov byte [di + 1], 0xaa
    87 00000013 31C0                        xor  ax, ax
    88 00000015 8ED8                        mov  ds, ax
    89 00000017 8EC0                        mov  es, ax
    90                                  
    91                                      ; set up stack
    92 00000019 B8E007                      mov  ax, ram_start >> 4
    93 0000001C 8ED0                        mov  ss, ax
    94 0000001E BC0010                      mov  sp, stack_start
    95                                  
    96                                      ; use mode 13h temporarily, for rendering text
    97 00000021 B81300                      mov  ax, 0x13
    98 00000024 CD10                        int  0x10
    99 00000026 BB0F00                      mov  bx, 0x0F
   100 00000029 B40E                        mov  ah, 0x0E
   101 0000002B BE[D101]                    mov  si, text
   102                                  load_text:
   103 0000002E AC                          lodsb
   104 0000002F CD10                        int  0x10
   105 00000031 3CAA                        cmp  al, 0xAA  ; stop at end-of-MBR marker
   106 00000033 75F9                        jne  load_text
   107                                  
   108                                      ; save rendered text to RAM
   109 00000035 1E                          push ds
   110 00000036 6800A0                      push vram_start >> 4
   111 00000039 1F                          pop  ds
   112 0000003A 31F6                        xor  si, si
   113 0000003C BF009E                      mov  di, ram_start + rendered_text
   114 0000003F B90014                      mov  cx, 320*text_num*text_height / 2
   115 00000042 F3A5                        rep movsw
   116 00000044 1F                          pop ds
   117                                  
   118                                      ; switch back to text mode
   119                                      ; going directly from 13h to 101h upsets
   120                                      ; some non-emulated hardware
   121 00000045 31C0                        xor ax, ax
   122 00000047 CD10                        int 0x10
   123                                  
   124                                      ; get info for VESA mode 101h
   125 00000049 B8014F                      mov  ax, 0x4F01
   126 0000004C B90101                      mov  cx, vesa_mode
   127 0000004F 51                          push cx
   128 00000050 BF007E                      mov  di, ram_start
   129 00000053 CD10                        int  0x10
   130                                  
   131                                      ; enter the VESA mode
   132 00000055 B8024F                      mov  ax, 0x4F02
   133 00000058 5B                          pop  bx
   134 00000059 CD10                        int  0x10
   135                                  
   136                                      ; compute 64 / window_granularity
   137                                      ; VESA call successful => ah = 0
   138 0000005B B040                        mov  al, 64
   139 0000005D 31D2                        xor  dx, dx
   140 0000005F F77504                      div  word [di+4]
   141 00000062 50                          push ax  ;; MUST BE BOTTOM PUSH
   142                                  
   143                                      ; set up a palette
   144                                      ; we assume the VESA mode has a VGA-compatible DAC
   145 00000063 BAC803                      mov  dx, vga_dac_addr
   146 00000066 30C0                        xor  al, al
   147 00000068 EE                          out  dx, al
   148 00000069 42                          inc  dx
   149                                  
   150                                      ; 6-bit RGB values in al, bh, ch
   151                                      ; cx used for termination too
   152 0000006A 31C9                        xor  cx, cx
   153                                  palette:
   154                                      ; worth saving al due to short operands
   155 0000006C 50                          push ax
   156 0000006D EE                          out  dx, al
   157 0000006E 88F8                        mov  al, bh
   158 00000070 EE                          out  dx, al
   159 00000071 88E8                        mov  al, ch
   160 00000073 EE                          out  dx, al
   161 00000074 58                          pop  ax
   162 00000075 0401                        add  al, inc_red   >> 2
   163 00000077 81C34001                    add  bx, inc_green << 6
   164 0000007B 81C18001                    add  cx, inc_blue  << 6
   165 0000007F 75EB                        jnz  palette
   166                                  
   167                                      ; initialize the FPU with some constants
   168 00000081 DBE3                        fninit
   169 00000083 C7058500                    mov  word [di], height_scale
   170 00000087 DF05                        fild word [di]
   171 00000089 C605B1                      mov  byte [di], width_scale
   172 0000008C DF05                        fild word [di]
   173                                  
   174                                      ; initialize frame counter and segments
   175 0000008E 31ED                        xor  bp, bp
   176                                  
   177                                      ; select first buffer for reading
   178 00000090 680010                      push 0x1000
   179 00000093 0FA1                        pop  fs
   180                                  
   181                                  
   182                                  ;;;; MAIN LOOP
   183                                  main_loop:
   184                                      ; restore clobbered ds
   185 00000095 16                          push ss
   186 00000096 1F                          pop  ds
   187 00000097 60                          pusha
   188 00000098 B401                        mov ah, 0x01
   189 0000009A CD16                        int 0x16
   190 0000009C 0F852601                    jnz end
   191 000000A0 61                          popa
   192                                  
   193                                  
   194                                  ;;;; TEXT BLIT
   195                                      ; draw text into the read buffer
   196 000000A1 8CE0                        mov  ax, fs
   197 000000A3 80C410                      add  ah, 0x10
   198 000000A6 8EC0                        mov  es, ax
   199                                  
   200 000000A8 BE0020                      mov  si, rendered_text
   201 000000AB F7C50004                    test bp, 0x400
   202 000000AF 7404                        jz   text_first_message
   203                                      ; draw the second message sometimes
   204 000000B1 81C60014                    add  si, text_height * 320
   205                                  text_first_message:
   206 000000B5 BFC078                      mov  di, width * text_y + text_x
   207                                  text_blit:
   208                                      ; cx cleared by previous loop
   209 000000B8 B140                        mov  cl, text_width
   210                                  text_blit_row:
   211 000000BA AC                          lodsb
   212 000000BB 260005                      add  [es:di], al
   213 000000BE 47                          inc  di
   214 000000BF E2F9                        loop text_blit_row
   215 000000C1 81C60001                    add  si, 320 - text_width
   216 000000C5 81C7C001                    add  di, width - text_width
   217 000000C9 81FF0098                    cmp  di, width * (text_y + text_height)
   218 000000CD 72E9                        jb   text_blit
   219                                  
   220                                  
   221                                  ;;;; FEEDBACK
   222 000000CF 31F6                        xor  si, si
   223 000000D1 31FF                        xor  di, di
   224                                  
   225                                      ; initialize write segment register
   226 000000D3 8CE0                        mov  ax, fs
   227 000000D5 80F450                      xor  ah, 0x50
   228 000000D8 8EC0                        mov  es, ax
   229                                  
   230                                      ; push frame count to the FPU stack and scale
   231                                      ; by width (arbitrary, convenient)
   232 000000DA 892C                        mov [si], bp
   233 000000DC DF04                        fild word [si]
   234 000000DE D8F1                        fdiv st1
   235                                  
   236                                      ; FPU stack: t h w
   237                                  
   238 000000E0 D9C0                        fld  st0
   239 000000E2 D9FF                        fcos
   240 000000E4 D9C9                        fxch
   241 000000E6 D9EA                        fldl2e     ; rel. period of k control pt.
   242 000000E8 DEC9                        fmul
   243 000000EA D9FF                        fcos
   244                                  
   245                                      ; Move control point in a polar flower:
   246                                      ;   j = cos(t)
   247                                      ;   k = cos(log_2(e) * t)
   248                                      ;
   249                                      ; stack: j k h w
   250                                  
   251                                      ; offset control point to an interesting region
   252                                      ; center at (-ln(2) + 0i)
   253                                      ; flower radius 0.5
   254 000000EC D9E8                        fld1
   255 000000EE D8C0                        fadd  st0
   256 000000F0 DCFA                        fdiv  st2, st0
   257 000000F2 DEF9                        fdivp st1, st0
   258 000000F4 D9ED                        fldln2
   259 000000F6 DEE9                        fsubp st1, st0
   260                                  
   261                                      ; loop over pixels in the write buffer
   262 000000F8 BA8001                      mov  dx, height
   263                                  compute_row:
   264 000000FB B90002                      mov  cx, width
   265                                  compute_pix:
   266                                  
   267 000000FE 60                          pusha
   268                                  
   269 000000FF D9EA                        fldl2e  ; used to offset viewport center to origin
   270                                  
   271                                      ; stack: o j k h w
   272                                  
   273 00000101 8914                        mov  [si], dx
   274 00000103 DF04                        fild word [si]
   275 00000105 D8F5                        fdiv st5
   276 00000107 D8E1                        fsub st1
   277                                  
   278                                      ; stack: y o j k h w
   279                                  
   280 00000109 890C                        mov  [si], cx
   281 0000010B DF04                        fild word [si]
   282 0000010D D8F5                        fdiv st5
   283 0000010F D8E2                        fsub st2
   284                                  
   285                                      ; stack: x y o j k h w
   286                                  
   287 00000111 DDD2                        fst   st2
   288 00000113 DCCA                        fmul  st2, st0
   289 00000115 D9C1                        fld   st1
   290 00000117 D8C8                        fmul  st0
   291 00000119 DEEB                        fsubp st3, st0
   292                                  
   293                                      ; stack: x y (x^2 - y^2) j k h w
   294                                  
   295 0000011B DEC9                        fmul
   296 0000011D D8C0                        fadd st0
   297                                  
   298                                      ; stack: 2xy (x^2 - y^2) j k h w
   299                                  
   300 0000011F D8C3                        fadd  st3
   301 00000121 D9C2                        fld   st2
   302 00000123 DEC2                        faddp st2, st0
   303                                  
   304                                      ; stack: 2xy+k (x^2 - y^2)+j j k h w
   305                                  
   306 00000125 D9EA                        fldl2e
   307 00000127 DCC2                        fadd  st2, st0
   308 00000129 DEC1                        faddp st1, st0
   309                                  
   310                                      ; stack: (2xy + o) ((x^2 - y^2) + o) j k h w
   311                                  
   312 0000012B D8CD                        fmul  st5
   313 0000012D DF1C                        fistp word [si]
   314 0000012F 8B14                        mov   dx, [si]
   315                                      ; dx <- scaled (2xy + o)
   316                                  
   317 00000131 D8CB                        fmul  st3
   318 00000133 DF1C                        fistp word [si]
   319 00000135 8B1C                        mov   bx, [si]
   320                                      ; bx <- scaled ((x^2 - y^2) + o)
   321                                  
   322                                  
   323                                      ; wrap x coordinate
   324 00000137 80E701                      and  bh, 0x01
   325                                  
   326                                      ; default color for out-of-bounds pixels is 0
   327                                      ; al is 0 from earlier segment register load
   328                                  
   329                                      ; check bounds for y coordinate
   330 0000013A 81FA8001                    cmp  dx, height
   331 0000013E 7320                        jae  compute_write
   332                                  
   333                                      ; extract segment from top 2 bits of y
   334 00000140 D1E2                        shl  dx, 1
   335 00000142 C0E604                      shl  dh, 4
   336 00000145 8CE0                        mov  ax, fs
   337 00000147 00F4                        add  ah, dh
   338 00000149 8EE8                        mov  gs, ax
   339                                  
   340                                      ; fetch at offset (y*width + x)
   341                                      ; width = 2**9, shifted 1 already
   342 0000014B 30F6                        xor  dh, dh
   343 0000014D C1E208                      shl  dx, 8
   344 00000150 01D3                        add  bx, dx
   345 00000152 658A07                      mov  al, [gs:bx]
   346                                  
   347                                      ; clamp color to avoid super blinky center regions
   348 00000155 3CF0                        cmp  al, 0xF0
   349 00000157 7307                        jae  compute_write
   350                                  
   351                                      ; color shift per map iteration, varying over time
   352 00000159 89EB                        mov  bx, bp
   353 0000015B 80E70F                      and  bh, 0x0F
   354 0000015E 00F8                        add  al, bh
   355                                  
   356                                  compute_write:
   357 00000160 268805                      mov  [es:di], al
   358                                  
   359 00000163 61                          popa
   360                                  
   361                                      ; next column, output pixel
   362 00000164 47                          inc  di
   363 00000165 E297                        loop compute_pix
   364                                  
   365                                      ; advance write segment when di wraps
   366 00000167 85FF                        test di, di
   367 00000169 7507                        jnz  compute_no_seginc
   368 0000016B 8CC0                        mov  ax, es
   369 0000016D 80C410                      add  ah, 0x10
   370 00000170 8EC0                        mov  es, ax
   371                                  
   372                                  compute_no_seginc:
   373                                      ; next row
   374 00000172 4A                          dec  dx
   375 00000173 7586                        jnz  compute_row
   376                                  
   377                                      ; bump frame counter
   378 00000175 45                          inc  bp
   379                                  
   380                                      ; discard j, k from FPU stack
   381 00000176 DED9                        fcompp
   382                                  
   383                                  
   384                                  ;;;; DRAW TO SCREEN
   385                                      ; swap feedback buffers
   386 00000178 8CE0                        mov  ax, fs
   387 0000017A 80F450                      xor  ah, 0x50
   388 0000017D 8EE0                        mov  fs, ax
   389 0000017F 8ED8                        mov  ds, ax
   390                                  
   391                                      ; access graphics memory through segment es
   392 00000181 6800A0                      push vram_start >> 4
   393 00000184 07                          pop  es
   394                                  
   395                                      ; reset our window into VRAM
   396                                      ; dx is 0 from earlier loop
   397 00000185 E83600                      call setwin
   398                                  
   399                                      ; copy beginning of feedback buffer to
   400                                      ; center of screen
   401 00000188 31F6                        xor  si, si
   402 0000018A BF4078                      mov  di, 48*640 + 64
   403                                  
   404 0000018D BB8001                      mov  bx, height
   405                                  draw_row:
   406 00000190 B90002                      mov  cx, width
   407                                  draw_pix:
   408 00000193 A4                          movsb
   409                                  
   410                                      ; advance the graphics window by 64k when di wraps
   411 00000194 85FF                        test di, di
   412 00000196 750A                        jnz  draw_no_wininc
   413 00000198 360216FE0F                  add  dl, [ss:stack_start-2]
   414 0000019D 53                          push bx
   415 0000019E E81D00                      call setwin
   416 000001A1 5B                          pop  bx
   417                                  
   418                                  draw_no_wininc:
   419 000001A2 E2EF                        loop draw_pix
   420                                  
   421                                      ; end of row: 128 pixels of left/right border
   422 000001A4 81C78000                    add  di, 128
   423 000001A8 4B                          dec  bx
   424                                  
   425                                      ; advance read segment when !(row & 0x7F)
   426 000001A9 F6C37F                      test bl, 0x7F
   427 000001AC 7509                        jnz  draw_no_seginc
   428 000001AE 8CD8                        mov  ax, ds
   429 000001B0 80C410                      add  ah, 0x10
   430 000001B3 8ED8                        mov  ds, ax
   431 000001B5 31F6                        xor  si, si
   432                                  
   433                                  draw_no_seginc:
   434 000001B7 85DB                        test bx, bx
   435 000001B9 75D5                        jnz  draw_row
   436                                  
   437 000001BB E9D7FE                      jmp  main_loop
   438                                  
   439                                  
   440                                  setwin:
   441                                      ; call the VESA BIOS to set the VRAM window
   442 000001BE B8054F                      mov  ax, 0x4F05
   443 000001C1 31DB                        xor  bx, bx
   444 000001C3 CD10                        int  0x10
   445 000001C5 C3                          ret
   446                                  
   447                                  end:
   448 000001C6 31C0                        xor ax, ax
   449 000001C8 CD16                        int 0x16
   450 000001CA B80300                      mov ax,0x0003           ; Restore text mode
   451 000001CD CD10                        int 0x10
   452 000001CF CD20                        int 0x20
   453                                  
   454                                  text:
   455 000001D1 31323334                    db "1234"
   456                                  ;;;; PROGRAM END
   457                                  
   458                                  
   459                                  ; MBR required data
   460                                  padding:
   461 000001D5 FF<rept>                    times 510 - ($-$$) db 0xff
   462                                  signature:
   463 000001FE 55AA                        db 0x55, 0xaa
   464                                  
   465                                  ; vim: ft=tasm
