     1                                          ;
     2                                          ; bootBASIC interpreter in 512 bytes (boot sector)
     3                                          ;
     4                                          ; by Oscar Toledo G.
     5                                          ; http://nanochess.org/
     6                                          ;
     7                                          ; (c) Copyright 2019 Oscar Toledo G.
     8                                          ;
     9                                          ; Creation date: Jul/19/2019. 10pm to 12am.
    10                                          ; Revision date: Jul/20/2019. 10am to 2pm.
    11                                          ;                             Added assignment statement. list now
    12                                          ;                             works. run/goto now works. Added
    13                                          ;                             system and new.
    14                                          ; Revision date: Jul/22/2019. Boot image now includes 'system'
    15                                          ;                             statement.
    16                                          ;
    17                                  
    18                                          ;
    19                                          ; USER'S MANUAL:
    20                                          ;
    21                                          ; Line entry is done with keyboard, finish the line with Enter.
    22                                          ; Only 19 characters per line as maximum.
    23                                          ;
    24                                          ; Backspace can be used, don't be fooled by the fact
    25                                          ; that screen isn't deleted (it's all right in the buffer).
    26                                          ;
    27                                          ; All statements must be in lowercase.
    28                                          ;
    29                                          ; Line numbers can be 1 to 999.
    30                                          ;
    31                                          ; 26 variables are available (a-z)
    32                                          ;
    33                                          ; Numbers (0-65535) can be entered and display as unsigned.
    34                                          ;
    35                                          ; To enter new program lines:
    36                                          ;   10 print "Hello, world!"
    37                                          ;
    38                                          ; To erase program lines:
    39                                          ;   10
    40                                          ;
    41                                          ; To test statements directly (interactive syntax):
    42                                          ;   print "Hello, world!"
    43                                          ;
    44                                          ; To erase the current program:
    45                                          ;   new
    46                                          ;
    47                                          ; To run the current program:
    48                                          ;   run
    49                                          ;
    50                                          ; To list the current program:
    51                                          ;   list
    52                                          ;
    53                                          ; To exit to command-line:
    54                                          ;   !
    55                                  	; To save the file (can be loaded with loadb):
    56                                  	;   *
    57                                  	;
    58                                          ;
    59                                          ; Statements:
    60                                          ;   var=expr        Assign expr value to var (a-z)
    61                                          ;
    62                                          ;   print expr      Print expression value, new line
    63                                          ;   print expr;     Print expression value, continue
    64                                          ;   print "hello"   Print string, new line
    65                                          ;   print "hello";  Print string, continue
    66                                          ;
    67                                          ;   input var       Input value into variable (a-z)
    68                                          ;
    69                                          ;   goto expr       Goto to indicated line in program
    70                                          ;
    71                                          ;   if expr1 goto expr2
    72                                          ;               If expr1 is non-zero then go to line,
    73                                          ;               else go to following line.
    74                                          ;
    75                                          ; Examples of if:
    76                                          ;
    77                                          ;   if c-5 goto 20  If c isn't 5, go to line 20
    78                                          ;
    79                                          ; Expressions:
    80                                          ;
    81                                          ;   The operators +, -, / and * are available with
    82                                          ;   common precedence rules and signed operation.
    83                                          ;
    84                                          ;   You can also use parentheses:
    85                                          ;
    86                                          ;      5+6*(10/2)
    87                                          ;
    88                                          ;   Variables and numbers can be used in expressions.
    89                                          ;
    90                                          ; Sample program (counting 1 to 10):
    91                                          ;
    92                                          ; 10 a=1
    93                                          ; 20 print a
    94                                          ; 30 a=a+1
    95                                          ; 40 if a-11 goto 20
    96                                          ;
    97                                          ; Sample program (Pascal's triangle, each number is the sum
    98                                          ; of the two over it):
    99                                          ;
   100                                          ; 10 input n
   101                                          ; 20 i=1
   102                                          ; 30 c=1
   103                                          ; 40 j=0
   104                                          ; 50 t=n-i
   105                                          ; 60 if j-t goto 80
   106                                          ; 70 goto 110
   107                                          ; 80 print " ";
   108                                          ; 90 j=j+1
   109                                          ; 100 goto 50
   110                                          ; 110 k=1
   111                                          ; 120 if k-i-1 goto 140
   112                                          ; 130 goto 190
   113                                          ; 140 print c;
   114                                          ; 150 c=c*(i-k)/k
   115                                          ; 160 print " ";
   116                                          ; 170 k=k+1
   117                                          ; 180 goto 120
   118                                          ; 190 print
   119                                          ; 200 i=i+1
   120                                          ; 210 if i-n-1 goto 30
   121                                          ;
   122                                  
   123                                          cpu 8086
   124                                  
   125                                      %ifndef com_file    ; If not defined create a boot sector
   126                                  com_file:       equ 0
   127                                      %endif
   128                                  
   129                                      %if com_file
   130                                          org 0x0100
   131                                      %else
   132                                          org 0x7c00
   133                                      %endif
   134                                  
   135                                  vars:       equ 0x7e00  ; Variables (multiple of 256)
   136                                  running:    equ 0x7e7e  ; Running status
   137                                  line:       equ 0x7e80  ; Line input
   138                                  program:    equ 0x7f00  ; Program address
   139                                  stack:      equ 0xff00  ; Stack address
   140                                  max_line:   equ 1000    ; First unavailable line number
   141                                  max_length: equ 20      ; Maximum length of line
   142                                  max_size:   equ max_line*max_length ; Max. program size
   143                                  
   144                                  start:
   145                                      %if com_file
   146                                      %else
   147 00000000 0E                              push cs         ; For boot sector
   148 00000001 0E                              push cs         ; it needs to setup
   149 00000002 0E                              push cs         ; DS, ES and SS.
   150 00000003 1F                              pop ds
   151 00000004 07                              pop es
   152 00000005 17                              pop ss
   153                                      %endif
   154 00000006 FC                              cld             ; Clear Direction flag
   155 00000007 803EFCFF00              	cmp byte [0xfffc], 0x00	; dirty byte
   156 0000000C 750A                    	jne main_loop
   157 0000000E BF007F                          mov di,program  ; Point to program
   158 00000011 B00D                            mov al,0x0d     ; Fill with CR
   159 00000013 B9204E                          mov cx,max_size ; Max. program size
   160 00000016 F3AA                            rep stosb       ; Initialize
   161                                  
   162                                          ;
   163                                          ; Main loop
   164                                          ;
   165                                  main_loop:
   166 00000018 BC00FF                          mov sp,stack    ; Reinitialize stack pointer
   167 0000001B CDA0                    	int 0xa0
   168 0000001D B8[1800]                        mov ax,main_loop
   169 00000020 50                              push ax
   170 00000021 31C0                            xor ax,ax       ; Mark as interactive
   171 00000023 A37E7E                          mov [running],ax
   172 00000026 B025                            mov al,'%'      ; Show prompt
   173 00000028 CD26                            int 0x26 ; Accept line
   174 0000002A E8EC00                          call input_number       ; Get number
   175 0000002D 09C0                            or ax,ax        ; No number or zero?
   176 0000002F 7411                            je statement    ; Yes, jump
   177 00000031 E82301                          call find_line  ; Find the line
   178 00000034 97                              xchg ax,di      
   179                                  ;       mov cx,max_length       ; CX loaded with this value in 'find_line'
   180 00000035 F3A4                            rep movsb       ; Copy entered line into program
   181                                  sharp_command:        
   182 00000037 C3                      	ret
   183                                  
   184                                          ;
   185                                          ; Handle 'if' statement
   186                                          ;
   187                                  if_statement:
   188 00000038 E85100                          call expr       ; Process expression
   189 0000003B 09C0                            or ax,ax        ; Is it zero?
   190 0000003D 7503E97601                      je f6           ; Yes, return (ignore if)
   191                                  statement:
   192 00000042 E8B800                          call spaces     ; Avoid spaces
   193 00000045 803C0D                          cmp byte [si],0x0d  ; Empty line?
   194 00000048 7503E96B01                      je f6           ; Yes, return
   195 0000004D BF[CE01]                        mov di,statements   ; Point to statements list
   196 00000050 8A05                    f5:     mov al,[di]     ; Read length of the string
   197 00000052 47                              inc di          ; Avoid length byte
   198 00000053 25FF00                          and ax,0x00ff   ; Is it zero?
   199 00000056 7413                            je f4           ; Yes, jump
   200 00000058 91                              xchg ax,cx
   201 00000059 56                              push si         ; Save current position
   202 0000005A F3A6                    f16:    rep cmpsb       ; Compare statement
   203 0000005C 7506                            jne f3          ; Equal? No, jump
   204 0000005E 58                              pop ax
   205 0000005F E89B00                          call spaces     ; Avoid spaces
   206 00000062 FF25                            jmp word [di]   ; Jump to process statement
   207                                  
   208 00000064 01CF                    f3:     add di,cx       ; Advance the list pointer
   209 00000066 47                              inc di          ; Avoid the address
   210 00000067 47                              inc di
   211 00000068 5E                              pop si
   212 00000069 EBE5                            jmp f5          ; Compare another statement
   213                                  
   214 0000006B E88800                  f4:     call get_variable       ; Try variable
   215 0000006E 50                              push ax         ; Save address
   216 0000006F AC                              lodsb           ; Read a line letter
   217 00000070 3C3D                            cmp al,'='      ; Is it assignment '=' ?
   218 00000072 7412                            je assignment   ; Yes, jump to assignment.
   219                                  
   220                                          ;
   221                                          ; An error happened
   222                                          ;
   223                                  error:
   224 00000074 BE[7C00]                        mov si,error_message
   225 00000077 E8EF00                          call print_2    ; Show error message
   226 0000007A EB9C                            jmp main_loop   ; Exit to main loop
   227                                  
   228                                  error_message:
   229 0000007C 130D                            db 0x13,0x0d   ; Guess the words :P
   230                                  
   231                                  
   232                                          ;
   233                                          ; Handle 'input' statement
   234                                          ;
   235                                  input_statement:
   236 0000007E E87500                          call get_variable   ; Get variable address
   237 00000081 50                              push ax             ; Save it
   238 00000082 B03F                            mov al,'?'          ; Prompt
   239 00000084 CD26                            int 0x26     ; Wait for line
   240                                          ;
   241                                          ; Second part of the assignment statement
   242                                          ;
   243                                  assignment:
   244 00000086 E80300                          call expr           ; Process expression
   245 00000089 5F                              pop di
   246 0000008A AB                              stosw               ; Save onto variable
   247 0000008B C3                              ret
   248                                  
   249                                          ;
   250                                          ; Handle an expression.
   251                                          ; First tier: addition & subtraction.
   252                                          ;
   253                                  expr:
   254 0000008C E81F00                          call expr1          ; Call second tier
   255 0000008F 803C2D                  f20:    cmp byte [si],'-'   ; Subtraction operator?
   256 00000092 7411                            je f19              ; Yes, jump
   257 00000094 803C2B                          cmp byte [si],'+'   ; Addition operator?
   258 00000097 7403E91C01                      jne f6              ; No, return
   259 0000009C 50                              push ax
   260 0000009D E80D00                          call expr1_2        ; Call second tier
   261 000000A0 59                      f15:    pop cx
   262 000000A1 01C8                            add ax,cx           ; Addition
   263 000000A3 EBEA                            jmp f20             ; Find more operators
   264                                  
   265                                  f19:
   266 000000A5 50                              push ax
   267 000000A6 E80400                          call expr1_2        ; Call second tier
   268 000000A9 F7D8                            neg ax              ; Negate it (a - b converted to a + -b)
   269 000000AB EBF3                            jmp f15
   270                                  
   271                                          ;
   272                                          ; Handle an expression.
   273                                          ; Second tier: division & multiplication.
   274                                          ;
   275                                  expr1_2:
   276 000000AD 46                              inc si              ; Avoid operator
   277                                  expr1:
   278 000000AE E82200                          call expr2          ; Call third tier
   279 000000B1 803C2F                  f21:    cmp byte [si],'/'   ; Division operator?
   280 000000B4 7411                            je f23              ; Yes, jump
   281 000000B6 803C2A                          cmp byte [si],'*'   ; Multiplication operator?
   282 000000B9 7403E9FA00                      jne f6              ; No, return
   283                                  
   284 000000BE 50                              push ax
   285 000000BF E81000                          call expr2_2        ; Call third tier
   286 000000C2 59                              pop cx
   287 000000C3 F7E9                            imul cx             ; Multiplication
   288 000000C5 EBEA                            jmp f21             ; Find more operators
   289                                  
   290                                  f23:
   291 000000C7 50                              push ax
   292 000000C8 E80700                          call expr2_2        ; Call third tier
   293 000000CB 59                              pop cx
   294 000000CC 91                              xchg ax,cx
   295 000000CD 99                              cwd                 ; Expand AX to DX:AX
   296 000000CE F7F9                            idiv cx             ; Signed division
   297 000000D0 EBDF                            jmp f21             ; Find more operators
   298                                  
   299                                          ;
   300                                          ; Handle an expression.
   301                                          ; Third tier: parentheses, numbers and vars.
   302                                          ;
   303                                  expr2_2:
   304 000000D2 46                              inc si              ; Avoid operator
   305                                  expr2:
   306 000000D3 E82700                          call spaces         ; Jump spaces
   307 000000D6 AC                              lodsb               ; Read character
   308 000000D7 3C28                            cmp al,'('          ; Open parenthesis?
   309 000000D9 750A                            jne f24
   310 000000DB E8AEFF                          call expr           ; Process inner expr.
   311 000000DE 803C29                          cmp byte [si],')'   ; Closing parenthesis?
   312 000000E1 741F                            je spaces_2         ; Yes, avoid spaces
   313 000000E3 EB8F                            jmp error           ; No, jump to error
   314                                  
   315 000000E5 3C40                    f24:    cmp al,0x40         ; Variable?
   316 000000E7 7306                            jnc f25             ; Yes, jump
   317 000000E9 4E                              dec si              ; Back one letter...
   318 000000EA E82C00                          call input_number   ; ...to read number
   319 000000ED EB0E                            jmp spaces          ; Avoid spaces
   320                                          
   321 000000EF E80500                  f25:    call get_variable_2 ; Get variable address
   322 000000F2 93                              xchg ax,bx
   323 000000F3 8B07                            mov ax,[bx]         ; Read
   324 000000F5 C3                              ret                 ; Return
   325                                  
   326                                          ;
   327                                          ; Get variable address
   328                                          ;
   329                                  get_variable:
   330 000000F6 AC                              lodsb               ; Read source
   331                                  get_variable_2:
   332 000000F7 241F                            and al,0x1f         ; 0x61-0x7a -> 0x01-0x1a
   333 000000F9 00C0                            add al,al           ; x 2 (each variable = word)
   334 000000FB B47E                            mov ah,vars>>8      ; Setup high-byte of address
   335                                          ;
   336                                          ; Avoid spaces
   337                                          ;
   338                                  spaces:
   339 000000FD 803C20                          cmp byte [si],' '   ; Space found?
   340 00000100 752C                            jne f22             ; No, return
   341                                          ;
   342                                          ; Avoid spaces after current character
   343                                          ;
   344                                  spaces_2:
   345 00000102 46                              inc si              ; Advance to next character
   346 00000103 EBF8                            jmp spaces
   347                                  
   348                                          ;
   349                                          ; Output unsigned number 
   350                                          ; AX = value
   351                                          ;
   352                                  output_number:
   353                                  f26:
   354 00000105 31D2                            xor dx,dx           ; DX:AX
   355 00000107 B90A00                          mov cx,10           ; Divisor = 10
   356 0000010A F7F1                            div cx              ; Divide
   357 0000010C 09C0                            or ax,ax            ; Nothing at left?
   358 0000010E 52                              push dx
   359 0000010F 7403                            je f8               ; No, jump
   360 00000111 E8F1FF                          call f26            ; Yes, output left side
   361 00000114 58                      f8:     pop ax
   362 00000115 0430                            add al,'0'          ; Output remainder as...
   363 00000117 EB6C                            jmp output          ; ...ASCII digit
   364                                  
   365                                          ;
   366                                          ; Read number in input
   367                                          ; AX = result
   368                                          ;
   369                                  input_number:
   370 00000119 31DB                            xor bx,bx           ; BX = 0
   371 0000011B AC                      f11:    lodsb               ; Read source
   372 0000011C 2C30                            sub al,'0'
   373 0000011E 3C0A                            cmp al,10           ; Digit valid?
   374 00000120 98                              cbw
   375 00000121 93                              xchg ax,bx
   376 00000122 7309                            jnc f12             ; No, jump
   377 00000124 B90A00                          mov cx,10           ; Multiply by 10
   378 00000127 F7E1                            mul cx
   379 00000129 01C3                            add bx,ax           ; Add new digit
   380 0000012B EBEE                            jmp f11             ; Continue
   381                                  
   382 0000012D 4E                      f12:    dec si              ; SI points to first non-digit
   383                                  f22:
   384 0000012E C3                              ret
   385                                  
   386                                  
   387                                          ;
   388                                          ; Handle 'goto' statement
   389                                          ;
   390                                  goto_statement:
   391 0000012F E85AFF                          call expr           ; Handle expression
   392 00000132 B9                              db 0xb9             ; MOV CX to jump over XOR AX,AX
   393                                  
   394                                          ;
   395                                          ; Handle 'run' statement
   396                                          ; (equivalent to 'goto 0')
   397                                          ;
   398                                  run_statement:
   399 00000133 31C0                            xor ax,ax           
   400                                  f10:
   401 00000135 E81F00                          call find_line      ; Find line in program
   402 00000138 833E7E7E00              f27:    cmp word [running],0 ; Already running?
   403 0000013D 7404                            je f31
   404 0000013F A37E7E                          mov [running],ax    ; Yes, target is new line
   405 00000142 C3                              ret
   406                                  f31:
   407 00000143 50                              push ax
   408 00000144 5E                              pop si
   409 00000145 83C014                          add ax,max_length   ; Point to next line
   410 00000148 A37E7E                          mov [running],ax    ; Save for next time
   411 0000014B E8F4FE                          call statement      ; Process current statement
   412 0000014E A17E7E                          mov ax,[running]
   413 00000151 3D20CD                          cmp ax,program+max_size ; Reached the end?
   414 00000154 75ED                            jne f31             ; No, continue
   415 00000156 C3                              ret                 ; Yes, return
   416                                  
   417                                          ;
   418                                          ; Find line in program
   419                                          ; Entry:
   420                                          ;   ax = line number
   421                                          ; Result:
   422                                          ;   ax = pointer to program
   423                                  find_line:
   424 00000157 B91400                          mov cx,max_length
   425 0000015A F7E1                            mul cx
   426 0000015C 05007F                          add ax,program
   427 0000015F C3                              ret
   428                                  
   429                                          ;
   430                                          ; Handle "print" statement
   431                                          ;
   432                                  print_statement:
   433 00000160 AC                              lodsb           ; Read source
   434 00000161 3C0D                            cmp al,0x0d     ; End of line?
   435 00000163 7424                            je new_line     ; Yes, generate new line and return
   436 00000165 3C22                            cmp al,'"'      ; Double quotes?
   437 00000167 750B                            jne f7          ; No, jump
   438                                  print_2:
   439                                  f9:
   440 00000169 AC                              lodsb           ; Read string contents
   441 0000016A 3C22                            cmp al,'"'      ; Double quotes?
   442 0000016C 740D                            je f18          ; Yes, jump
   443 0000016E E81400                          call output     ; Output character
   444 00000171 75F6                            jne f9          ; Jump if not finished with 0x0d (CR)
   445 00000173 C3                              ret             ; Return
   446                                  
   447 00000174 4E                      f7:     dec si
   448 00000175 E814FF                          call expr       ; Handle expression
   449 00000178 E88AFF                          call output_number      ; Output result
   450 0000017B AC                      f18:    lodsb           ; Read next character
   451 0000017C 3C3B                            cmp al,';'      ; Is it semicolon?
   452 0000017E 7509                            jne new_line    ; No, jump to generate new line
   453 00000180 C3                              ret             ; Yes, return
   454                                  
   455                                          ;
   456                                          ; Read a key into al
   457                                          ; Also outputs it to screen
   458                                          ;
   459                                  input_key:
   460 00000181 B400                            mov ah,0x00
   461 00000183 CD16                            int 0x16
   462                                          ;
   463                                          ; Screen output of character contained in al
   464                                          ; Expands 0x0d (CR) into 0x0a 0x0d (LF CR)
   465                                          ;
   466                                  output:
   467 00000185 3C0D                            cmp al,0x0d
   468 00000187 7507                            jne f17
   469                                          ;
   470                                          ; Go to next line (generates LF+CR)
   471                                          ;
   472                                  new_line:
   473 00000189 B00A                            mov al,0x0a
   474 0000018B E80200                          call f17
   475 0000018E B00D                            mov al,0x0d
   476                                  f17:
   477 00000190 B40E                            mov ah,0x0e
   478 00000192 BB0700                          mov bx,0x0007
   479 00000195 CD10                            int 0x10
   480 00000197 3C0D                            cmp al,0x0d
   481 00000199 C3                              ret
   482                                  
   483                                  list_statement:
   484 0000019A 31C0                            xor ax,ax       ; Start from line zero
   485 0000019C 50                      f29:    push ax
   486 0000019D E8B7FF                          call find_line  ; Find program line
   487 000001A0 96                              xchg ax,si
   488 000001A1 803C0D                          cmp byte [si],0x0d ; Empty line?
   489 000001A4 740B                            je f30          ; Yes, jump
   490 000001A6 58                              pop ax
   491 000001A7 50                              push ax
   492 000001A8 E85AFF                          call output_number ; Show line number
   493 000001AB AC                      f32:    lodsb           ; Show line contents
   494 000001AC E8D6FF                          call output
   495 000001AF 75FA                            jne f32         ; Jump if it wasn't 0x0d (CR)
   496 000001B1 58                      f30:    pop ax
   497 000001B2 40                              inc ax          ; Go to next line
   498 000001B3 3DE803                          cmp ax,max_line ; Finished?
   499 000001B6 75E4                            jne f29         ; No, continue
   500                                  f6:
   501 000001B8 C3                      	ret
   502                                  
   503                                  bye_statement:
   504 000001B9 C606FCFF00              		mov byte [0xfffc], 0x00
   505 000001BE CD20                    		int 0x20
   506                                  
   507                                  save_statement:
   508 000001C0 BF0081                  	mov di, 0x8100
   509 000001C3 E837FF                  	call spaces
   510 000001C6 89FB                    	mov bx, di
   511 000001C8 BF007F                  	mov di, program
   512 000001CB CD24                    	int 0x24
   513 000001CD C3                      	ret
   514                                  
   515                                          ;
   516                                          ; List of statements of bootBASIC
   517                                          ; First one byte with length of string
   518                                          ; Then string with statement
   519                                          ; Then a word with the address of the code
   520                                          ;
   521                                  statements:
   522                                  
   523 000001CE 0372756E                        db 3,"run"
   524 000001D2 [3301]                          dw run_statement
   525                                  
   526 000001D4 057072696E74                    db 5,"print"
   527 000001DA [6001]                          dw print_statement
   528                                  
   529 000001DC 05696E707574                    db 5,"input"
   530 000001E2 [7E00]                          dw input_statement
   531                                  
   532 000001E4 026966                          db 2,"if"
   533 000001E7 [3800]                          dw if_statement
   534                                  
   535 000001E9 04676F746F                      db 4,"goto"
   536 000001EE [2F01]                          dw goto_statement
   537                                  
   538 000001F0 012D                    	db 1,"-"
   539 000001F2 [9A01]                  	dw list_statement
   540                                  
   541 000001F4 012A                    	db 1,"*"
   542 000001F6 [C001]                  	dw save_statement
   543                                  
   544 000001F8 0121                            db 1,"!"
   545 000001FA [B901]                  	dw bye_statement
   546                                  
   547 000001FC 0123                    	db 1, "#"
   548 000001FE [3700]                  	dw sharp_command
   549                                  
   550                                  
