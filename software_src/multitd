	org 0x0000
target_irq:	equ 0x08
stack:		equ 0xf000

init:	mov si, 0x7c00	; point to code
	xor di, di	; will be copied to 0x10000
	mov ax, 0x1000	; set segment
	mov es, ax
	mov cx, init - end	; retrieve size
.loop:	cs lodsb		; load data ...
	es stosb		; ... and store it
	loop .loop
	jmp 0x1000:.start	; and jump
.start:	cli			; disable interrupts
	xchg ax, cx		; set ax to 0
	push ax			; and save it
	mov ds, ax		; set ds segment
	ds mov ax, word [target_irq * 4]	; to retrieve the original values of the interrupt table
	ds mov bx, word [target_irq * 4 + 2]
	mov word [emu_irq_table], ax		; and store them for emulation
	mov word [emu_irq_table + 2], bx
	pop ax					; load saved ax
	ds mov word [target_irq * 4], main	; set ip to main
	ds mov word [target_irq * 4 + 2], ax	; and use ax
	sti					; enable interrupts
	call save_table				; create a table entry for bootOS (ax is still zero)
	int 0x20				; and return
main:	cs mov [stack_pointer_save], sp		; save stack
	mov sp, stack				; set to a save stack
	call save_table				; and save all registers and sanitise them
	call next_pid				; goto next runnable pid
	call emu_irq				; emulate original irq to not crash the systems
	jmp return_execution			; return execution
save_table:	ret				; todo
next_pid:	ret				; todo
emu_irq:	ret				; you guessed it: todo
return_execution:	iret			; not todo (just kidding)

emu_irq_table:	dw 0, 0
stack_pointer_save:	dw 0
current_pid:	db 0
end:
times 510 - ($ - $$) nop
db 0x55, 0xaa
